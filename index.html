<!DOCTYPE html>
<html>
<head>
	<meta charset=utf-8>
	<title>Minecraft</title>
	<style>
		body {
			margin: 0;
		}

		canvas {
			width: 100%;
			height: 100%
		}

		#crosshair {
			position: absolute;
			color: #fff;
			font-size: 20px;
			font-weight: bold;
			left: 50%;
			top: 50%;
			transform: translate3d(-50%, -50%, 0);
		}
		#progress::after {
			position: absolute;
			height: 50px; width: 50px;
			border-radius: 50%;
			background: #fff;
			content: '';
			transform: scale(0);
		}
		#progress {
			position: absolute;
			left: 50%; top: 50%;
			height: 50px; width: 50px;
			border-radius: 50%;
			border: 2px solid #fff;
			opacity: 0;
			transform: translate3d(-50%, -50%, 0);
		}
		#progress.show {
			opacity: 0.8;
		}
		#progress.show::after {
			transform: scale(1);
			transition: transform 400ms linear;
		}
	</style>
</head>
<body>
<div id="crosshair">+</div>
<div id="progress"></div>
<script src="three.js"></script>
<script src="physi.js"></script>
<script src="pointerLock.js"></script>
<script src="terrain.js"></script>
<script src="noise.js"></script>
<script src="luminance.js"></script>
<script src="controls.js"></script>
<script>
	'use strict';
	Physijs.scripts.worker = '/physi_worker.js';
	Physijs.scripts.ammo = '/ammo.js';

	var scene, camera, renderer, controls, raycaster, spotLight, cursor, windowHeight, windowWidth, progress;
	var moveForward, moveBackward, moveLeft, moveRight, canJump, playerHeight, prevTime, velocity, cubes, player;
	var geometryBlock, geometryWater, materials;

	function init () {
		// init threejs
		scene = new Physijs.Scene;
		windowHeight = window.innerHeight;
		windowWidth = window.innerWidth;

		camera = new THREE.PerspectiveCamera(60, windowWidth / windowHeight, 0.3, 20);
		renderer = new THREE.WebGLRenderer();
		controls = new THREE.PointerLockControls(camera);
		raycaster = new THREE.Raycaster();
		cursor = new THREE.Vector2();
		progress = document.getElementById('progress');

		// controls
		moveForward = false;
		moveBackward = false;
		moveLeft = false;
		moveRight = false;
		canJump = false;
		playerHeight = 6;
		prevTime = performance.now();
		velocity = new THREE.Vector3();
		cubes = [];

		scene.addEventListener('update', function () {
			controls.enabled && scene.simulate();
		});

//		scene.setGravity(0, 0, 0);

		scene.add(controls.getObject());
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.shadowMap.enabled = true;
		renderer.shadowMap.soft = false;
		renderer.shadowMap.type = THREE.PCFSoftShadowMap;
		renderer.shadowMap.renderReverseSided = false;
		document.body.appendChild(renderer.domElement);

		// var axisHelper = new THREE.AxisHelper( 50 );
		// scene.add( axisHelper );

		// init lighting
		var ambientLight = new THREE.AmbientLight(0x666666);
		scene.add(ambientLight);
		spotLight = new THREE.SpotLight(0x999999);
		spotLight.position.set(30, 20, 0);
		spotLight.castShadow = true;
		spotLight.shadow.darkness = 0.1;
		spotLight.shadow.camera.near = 10;
		spotLight.shadow.camera.far = 50;
		spotLight.shadow.camera.fov = 80;
		spotLight.shadow.mapSize.width = 1024;
		spotLight.shadow.mapSize.height = 1024;
		spotLight.shadow.bias = -0.002;
		scene.add(spotLight);
		// scene.add(new THREE.DirectionalLightHelper(directionalLight1));
		// scene.add(new THREE.CameraHelper( spotLight.shadow.camera ));

		// load textures
		var loader = new THREE.TextureLoader();
		var texture_grass_top = Physijs.createMaterial(new THREE.MeshLambertMaterial(), 0.6, 0.3),
				texture_grass_side = Physijs.createMaterial(new THREE.MeshLambertMaterial(), 0.6, 0.3),
				texture_water = Physijs.createMaterial(new THREE.MeshLambertMaterial(), 0.6, 0.3),
				texture_dirt = Physijs.createMaterial(new THREE.MeshLambertMaterial(), 0.6, 0.3);

		loader.load('/images/grass.png', function (texture) {
			texture_grass_top.map = texture;
			texture_grass_top.needsUpdate = true;
		});
		loader.load('/images/grass_dirt.png', function (texture) {
			texture_grass_side.map = texture;
			texture_grass_side.needsUpdate = true;
		});
		loader.load('/images/dirt.png', function (texture) {
			texture_dirt.map = texture;
			texture_dirt.needsUpdate = true;
		});
		loader.load('/images/water.jpg', function (texture) {
			texture_water.map = texture;
			texture_water.transparent = true;
			texture_water.opacity = 0.7;
			texture_water.needsUpdate = true;
		});

		// init terrain
		geometryBlock = new THREE.BoxGeometry(1, 1, 1);
		geometryWater = new THREE.BoxGeometry(1, 0.8, 1);
		materials = {
			blockGrass: new THREE.MeshFaceMaterial([texture_grass_side, texture_grass_side, texture_grass_top, texture_dirt, texture_grass_side, texture_grass_side]),
			blockDirt: new THREE.MeshFaceMaterial([texture_dirt, texture_dirt, texture_dirt, texture_dirt, texture_dirt, texture_dirt]),
			blockWater: new THREE.MeshFaceMaterial([texture_water, texture_water, texture_water, texture_water, texture_water, texture_water])
		};


		// perlin noise terrain
		var terrain = [];
		noise.seed(Math.random());
		for (var x = 0; x < 32; x++) {
			terrain[x] = [];
			for (var y = 0; y < 32; y++) {
				var value = Math.floor(Math.abs(noise.perlin2(x / 32, y / 32)) * 10);
				terrain[x][y] = value;
			}
		}

		// diamond square terrain
		// var terrain = diamondSquareTerrain(5);
		for (var i = 0; i < terrain.length; i++) {
			for (var j = 0; j < terrain[i].length; j++) {
				var height = terrain[i][j];
				var cube;
				for (var h = 0; h <= height; h++) {
					var cube2 = null;
					if (h === height) {
						if(h === 0) {
							cube = new Physijs.BoxMesh(geometryBlock, texture_dirt, 0);
							cube2 = new Physijs.BoxMesh(geometryWater, texture_water, 0);
						} else {
							cube = new Physijs.BoxMesh(geometryBlock, materials['blockGrass'], 0);
						}
					} else {
						cube = new Physijs.BoxMesh(geometryBlock, texture_dirt, 0);
					}
					cube.castShadow = true;
					cube.receiveShadow = true;
					cube.position.set(16 - i, h, 16 - j);
					cube.collisions = 0;
					cubes.push(cube);
					scene.add(cube);

					if(cube2) {
						cube2.position.set(16 - i, h + 1 - 0.1, 16 - j);
						scene.add(cube2);
					}
				}
			}
		}

		player = new Physijs.BoxMesh(geometryBlock, texture_dirt);

		player.addEventListener('collision', function (a, b, c, d) {
			console.log('collision', a, b, c, d);
		});
		player.position.set(0, 10, -10);
		player.castShadow = true;
		player.rotation.set(
				Math.random() * Math.PI,
				Math.random() * Math.PI,
				Math.random() * Math.PI
		);
		scene.add(player);
//		player.setCcdMotionThreshold(1);
//		player.setCcdSweptSphereRadius(0.2);

		render();
		scene.simulate();
	}

	function getObjectAtCursor() {
		raycaster.ray.origin.copy(controls.getObject().position);
		raycaster.ray.direction.copy(camera.getWorldDirection());
		// raycaster.ray.far = 3;
		var intersections = raycaster.intersectObjects(scene.children);
		if(intersections.length) {
			return intersections[0].object;
		}
		return null;
	}

	function removeObject(object) {
		object && scene.remove(object);
	}

	// game loop
//	var startTime = Date.now();
	function render () {
		requestAnimationFrame(render);
		checkControls();
//		 var currentTime = Date.now();
//		 var elapsedTime = (currentTime - startTime)/1000;
//		 var localTime = ((elapsedTime % 1200) / 1200) + 0.85;
//		 spotLight.position.y = 30 * Math.cos(localTime * 2 * Math.PI);
//		 spotLight.position.x = 30 * Math.sin(localTime * 2 * Math.PI);
		renderer.render(scene, camera);
	}

	window.onload = init();


</script>
</body>
</html>
